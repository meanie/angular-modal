{"version":3,"sources":["append-animated.service.js","modal-overlay.service.js","modal-stack.service.js","modal.service.js"],"names":["module","angular","undefined","child","parent","window","children","length","overlayElement","class","numModals","zIndex","name","stack","i","splice","index","REASON_CANCEL","closeOnEsc","controller","controllerAs","resolve","locals","appendTo","overlay","wrapperClass","overlayClass","onBeforeClose","once","rejectOnDismissal","configs","modal","config","this","$get","_this","getResolvePromises","promises","$injector","push","item","openModal","element","closeOnClick","baseIndex","closeModal","$onInit","call","closedDeferred","$modalOverlay","hide","leave","scope","$destroy","$onDestroy","result","wasDismissed","then","outcome","modalInstance","catch","$q","reject","REASON_CLOSE_PREVENTED","confirmCloseModal","Modal","bodyElement","$document","find","eq","options","$modalStack","isOpen","extend","defaults","openedDeferred","defer","$$modal","opened","close","reason","event","addEventListener","isTextarea","tagName","which","all","getTemplatePromise","template","templateUrl","content","shift","$rootScope","$new","$scope","forEach","value","key","closeOthers","closeAll"],"mappings":"mJAIQA,EAAOC,EAAAC,kBAMbF,OAAO,qCAKL,mBAAsBG,WAAOC,SAAAA,2CAI9BC,OAAAA,EAAeJ,OAnBlB,ECAUI,EAAQJ,MAASC,EAAAA,EAAWI,EAAAA,EAAAC,OAAA,6DAKtCN,2JAgBE,IAAAO,OAAO,qDAcDC,iIA6BLJ,IAAQA,EAAOJ,EAhElB,GAAAS,EAAA,GCACF,EAAiBP,GAASC,MAAAA,OAAWS,gDAKtCV,uDAWS,cAAA,kLAmCDW,SACE,6BAKJ,GAAAC,EAAOC,GAAAF,OAAAA,wCAeP,SAAAA,GAAsBA,IAATA,EAAAA,kGAsBRP,GAAOJ,GC9FdY,EAAUE,OAAOC,EAAA,QAAkBX,OAAAA,OAAAJ,gPAKvCA,2IAkBE,IAAAgB,EAAgB,SACdC,EAAY,uBAKZC,UACAC,YAAAA,EACAC,cAAS,EACTC,SAAQ,KACRC,YAAU,KACVC,MAAAA,KACAC,WAAAA,KACAC,aAAc,QACdC,WACAC,OAAM,KACNC,SAAAA,+HAMFA,mBAAe,QAMbC,wCAOF,mDAAKC,iBAKMA,SAAMnB,EAAMoB,SAChBC,4DAYP,wDAAKC,+BAPHC,EAAKL,MAAQlB,EAAQX,IACrBgC,uOAiCSG,EAAAA,GAA6B,YAOhCC,EAAsBC,YAY5B,SATMD,QAASE,EAAaC,SAAAA,6DAGnBH,EAAAA,SAAAA,gDAMAI,gBAWPV,IAAAA,EAAMW,EAAiB/B,sHAMvBoB,EAAIA,QAAMY,GAAAA,MAAAA,OAAcC,EAAA,EAAAlC,EAAA,IAMhBmC,+JAcJd,EAAMZ,cACRY,EAAMZ,KAAW2B,EAAQC,6GAWnBhB,eAAMZ,SAAcY,oLAsB1BA,EAAMiB,SAMNjB,gFAMAkB,EAAAA,eAAcC,QAAAA,2BAOhBD,EACGE,0DAUGpB,EAAMqB,YAAMC,EAAAA,WAAAA,YACZtB,EAAMqB,WAAQE,WAAAP,KAAAhB,EAAAZ,YAIhBY,EAAMW,2CAMJX,QAAMb,gJAxCNa,EAAMF,MAAAA,YAsDPE,EAAMW,EAASa,EAAAC,sDAWYC,mBAA1BC,EAAW/B,cAAwB,OAG5BI,EAAAJ,cAAAgC,EAAAJ,EAAAC,8EAIPI,MAAOF,SAAAA,GACT,OAAOG,EAAGC,OAAOJ,GAAWK,KAKhC,QAAyBJ,IAAlBK,IAAyCR,IAARD,wBAM1C,OAAIU,EAAQN,EAAAJ,EAAAC,4CAxLVU,EAAcC,EAAAC,KAAA,QAAAC,GAAA,8BAsMOvC,iBAAflB,IACF0D,EAAUrE,QAEP,qBAMLqE,EAAYA,EAAQ1C,UAAQ2C,EAAAA,GAAYC,YACtC,GAAO5D,4FAKT0D,GAAAA,GAAQjD,EAAUiD,MAAQjD,EAAWmD,OAAA5D,GACrC0D,OAAQ/C,UAIAtB,EAAUwE,UAAAC,EAAAJ,8JAShBK,EAAAA,SAAmBC,OACnB5B,MAAAA,IAAAA,MAAgBa,uDAIhBnB,EAASzC,OAAQyC,uBAChB4B,EAAAA,0DAGHlE,OAAMuD,EAAAA,SACJkB,YAAS9C,EAAAA,QACTnB,QAAAA,EAAAA,QAAAA,gBACAkE,GAGAzD,WACSwB,SAETkC,OAToBhD,EAAA4C,eASdK,eACJjD,EAAOc,eAAWc,2EAKtBoB,MAAIT,SAAoBU,GACtBjD,OAAMb,EAAayC,EAASsB,GAAO,oDAQtBC,2BAAAA,IAAiBX,EAAWxC,OAAMb,qCAM/CiD,EAAMgB,GAAAA,iBAA2BC,UAAAA,EAAYlE,0CAK/CiD,IAAAA,EAAUc,EAAGC,SAAAA,EAAiBG,qEAG3BC,EACDC,WAAAA,iBAA2BC,EAAkBC,MAMrCC,GAAAA,iBAAmBC,UAAAA,EAAAA,kBAGzB5D,KAAMqB,EAAiBA,EAASwC,SAAAA,EAAYC,cAAAA,OAAAA,mBAAAA,EAAAA,EAAAA,YAAAA,KAAAA,SAAAA,+EAQpCvE,MAAAA,SAASqC,EAAAtC,QAGfC,EAAOwE,WAAe1C,YAMpBnD,OAAQ8F,EAAQzB,QACdhD,eAAc0E,gGAMlB/F,EAAQ8F,GAAQzB,IAMhBrE,EAAIqE,QAAQlD,EAAAA,QAAc,SAAA4E,EAAAC,GACxBlE,EAAMqB,GAAMkB,EAAQlD,UAItBnB,EAAAA,WAAgBqB,EAAQgD,EAAC0B,WAAe1E,GACtCS,EAAMZ,qDAKVlB,EAAIiG,QAAa5E,EAAA,SAAA0E,EAAAC,GACfhC,EAAMkC,WAAAA,GAAAA,IAMTvC,GACC7B,EAAM4C,kBAKVf,MAAOD,SAAAA,qIAsBXa,OAAOP,SAAAA","file":"angular-modal.min.js","sourcesContent":["(function(window, angular, undefined) {'use strict';\n/**\n * Module definition and dependencies\n */\nangular.module('AppendAnimated.Service', [])\n\n/**\n * Append animated helper\n */\n.factory('$appendAnimated', $animate => {\n  return function(child, parent) {\n    let children = parent.children();\n    if (children.length > 0) {\n      return $animate.enter(child, parent, children[children.length - 1]);\n    }\n    return $animate.enter(child, parent);\n  };\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ModalOverlay.Service', [\n  'AppendAnimated.Service',\n])\n\n/**\n * Modal overlay service\n */\n.factory('$modalOverlay', ($animate, $document, $appendAnimated) => {\n\n  //Global overlay element\n  let overlayElement;\n  let bodyElement = $document.find('body').eq(0);\n\n  /**\n   * Modal overlay service\n   */\n  return {\n\n    /**\n     * Show overlay element\n     */\n    show(overlayClass) {\n\n      //Already visible?\n      if (overlayElement) {\n        return;\n      }\n\n      //Create element\n      overlayElement = angular.element('<div></div>').attr({\n        class: overlayClass,\n      });\n\n      //Animate in\n      return $appendAnimated(overlayElement, bodyElement);\n    },\n\n    /**\n     * Hide overlay element\n     */\n    hide() {\n      if (overlayElement) {\n        $animate.leave(overlayElement);\n        overlayElement = null;\n      }\n    },\n\n    /**\n     * Set the proper z-index\n     */\n    setIndex(baseIndex, numModals) {\n      if (overlayElement) {\n        const zIndex = baseIndex + 2 * (numModals - 1);\n        overlayElement[0].style.zIndex = zIndex;\n      }\n    },\n  };\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ModalStack.Service', [])\n\n/**\n * Modal stack service\n */\n.factory('$modalStack', () => {\n\n  //Stack of modals\n  const stack = [];\n\n  //Modal stack interface\n  return {\n\n    /**\n     * Get modal instances stack (copy of the array)\n     */\n    get() {\n      return stack.map(instance => instance);\n    },\n\n    /**\n     * Check if there are open instances\n     */\n    isEmpty() {\n      return (stack.length === 0);\n    },\n\n    /**\n     * Get number of modals that are open\n     */\n    numOpen() {\n      return stack.length;\n    },\n\n    /**\n     * Check if a specific modal is open\n     */\n    isOpen(name) {\n\n      //Can't distinguish unnamed modals\n      if (!name) {\n        return false;\n      }\n\n      //Check if open\n      for (let i = 0; i < stack.length; i++) {\n        if (stack[i].name === name) {\n          return true;\n        }\n      }\n\n      //Not open\n      return false;\n    },\n\n    /**\n     * Check if a specific modal is last\n     */\n    isLast(name) {\n\n      //Can't distinguish unnamed modals or work with an empty stack\n      if (!name || stack.length === 0) {\n        return false;\n      }\n\n      //Get last modal and compare name\n      const last = stack[stack.length - 1];\n      return (last.name === name);\n    },\n\n    /**\n     * Add modal instance to stack\n     */\n    add(modalInstance) {\n      stack.push(modalInstance);\n    },\n\n    /**\n     * Remove modal instance from stack\n     */\n    remove(modalInstance) {\n      const index = stack.indexOf(modalInstance);\n      if (index > -1) {\n        stack.splice(index, 1);\n      }\n    },\n  };\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('Modal.Service', [\n  'ModalStack.Service',\n  'ModalOverlay.Service',\n  'AppendAnimated.Service',\n])\n\n/**\n * Modal service\n */\n.provider('$modal', function $modalProvider() {\n\n  //Reasons\n  const REASON_CANCEL = 'cancel';\n  const REASON_CLOSE_PREVENTED = 'close prevented';\n\n  /**\n   * Defaults\n   */\n  this.defaults = {\n    closeOnEsc: true,\n    closeOnClick: true,\n    template: null,\n    templateUrl: null,\n    scope: null,\n    controller: null,\n    controllerAs: '$ctrl',\n    resolve: {},\n    locals: null,\n    appendTo: null,\n    overlay: true,\n    wrapperClass: 'modal-wrapper ModalWrapper',\n    overlayClass: 'modal-overlay ModalOverlay',\n    onBeforeClose: null,\n    once: false,\n    rejectOnDismissal: false,\n  };\n\n  /**\n   * Store of predefined modal configs\n   */\n  this.configs = {};\n\n  /**\n   * Set defaults\n   */\n  this.setDefaults = function(defaults) {\n    this.defaults = angular.extend(this.defaults, defaults || {});\n    return this;\n  };\n\n  /**\n   * Predefine a modal config\n   */\n  this.modal = function(name, config) {\n\n    //Object hash given?\n    if (name && typeof name === 'object') {\n      angular.forEach(name, (config, name) => {\n        this.modal(name, config);\n      }, this);\n      return;\n    }\n\n    //Set config and return self\n    this.configs[name] = angular.extend({}, this.defaults, config || {});\n    return this;\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = function(\n    $rootScope, $q, $templateRequest, $injector, $controller,\n    $compile, $document, $animate, $modalStack, $modalOverlay,\n    $appendAnimated\n  ) {\n\n    //Get defaults and configs\n    const baseIndex = 10000;\n    const defaults = this.defaults;\n    const configs = this.configs;\n\n    //Get body element\n    const bodyElement = $document.find('body').eq(0);\n\n    /**\n     * Helper to get template promise\n     */\n    function getTemplatePromise(template, templateUrl) {\n      if (template) {\n        return $q.when(template);\n      }\n      return $templateRequest(templateUrl, true);\n    }\n\n    /**\n     * Helper to get resolve promises\n     */\n    function getResolvePromises(resolves) {\n      let promises = [];\n      angular.forEach(resolves, item => {\n        if (angular.isFunction(item) || angular.isArray(item)) {\n          promises.push($q.when($injector.invoke(item)));\n        }\n        else if (angular.isString(item)) {\n          promises.push($q.when($injector.get(item)));\n        }\n        else {\n          promises.push($q.when(item));\n        }\n      });\n      return promises;\n    }\n\n    /**\n     * Helper to open a modal\n     */\n    function openModal(modalInstance) {\n\n      //Access modal data object\n      const modal = modalInstance.$$modal;\n      const numModals = $modalStack.numOpen() + 1;\n\n      //Create then compile modal element\n      modal.element\n        .attr({class: modal.wrapperClass})\n        .html(modal.content);\n      modal.element = $compile(modal.element)(modal.scope);\n      modal.element[0].style.zIndex = baseIndex + (2 * numModals) - 1;\n\n      //Close on click handler\n      //NOTE: This is applied on the base modal element, e.g. invisible\n      //background, not the overlay. This is because clicking on the overlay\n      //would then close all modals, which is probably not what you'd want.\n      if (modal.closeOnClick) {\n        modal.element.on('click', event => {\n          if (event.target === event.currentTarget) {\n            event.preventDefault();\n            event.stopPropagation();\n            $rootScope.$apply(() => {\n              closeModal(modalInstance, REASON_CANCEL, true);\n            });\n          }\n        });\n      }\n\n      //Add to stack and show overlay\n      $modalStack.add(modalInstance);\n      if (modal.showOverlay) {\n        $modalOverlay.show(modal.overlayClass);\n        $modalOverlay.setIndex(baseIndex, numModals);\n      }\n\n      //Call controller $onInit\n      if (modal.controller && modal.controller.$onInit) {\n        modal.controller.$onInit.call(modal.controller);\n      }\n\n      //Resolve open\n      modal.openedDeferred.resolve(true);\n\n      //Append animated\n      return $appendAnimated(modal.element, modal.parent)\n        .then(() => {\n\n          //Call controller $postLink\n          if (modal.controller && modal.controller.$postLink) {\n            modal.controller.$postLink.call(modal.controller);\n          }\n        });\n    }\n\n    /**\n     * Helper to actually close modal once confirmed\n     */\n    function confirmCloseModal(modalInstance, result, wasDismissed) {\n\n      //Access modal data object\n      const modal = modalInstance.$$modal;\n      const numModals = $modalStack.numOpen() - 1;\n\n      //No element present?\n      if (!modal.element) {\n        return $q.when(true);\n      }\n\n      //If dismissed, use only closed deferred\n      if (wasDismissed) {\n        modal.closedDeferred.resolve(result);\n        if (modal.rejectOnDismissal) {\n          modal.resultDeferred.reject(result);\n        }\n      }\n      else {\n        modal.resultDeferred.resolve(result);\n      }\n\n      //Remove from stack\n      $modalStack.remove(modalInstance);\n      if ($modalStack.isEmpty()) {\n        $modalOverlay.hide();\n      }\n      else {\n        $modalOverlay.setIndex(baseIndex, numModals);\n      }\n\n      //Animate out\n      return $animate\n        .leave(modal.element)\n        .then(() => {\n\n          //Call controller on destroy now\n          if (modal.controller && modal.controller.$onDestroy) {\n            modal.controller.$onDestroy.call(modal.controller);\n          }\n\n          //Clean up scope\n          if (modal.scope) {\n            modal.scope.$destroy();\n            modal.scope = null;\n          }\n\n          //Remove element reference\n          modal.element = null;\n\n          //Remove event listeners\n          $document[0].removeEventListener('keydown', modal.broadcastEnter);\n          if (modal.closeOnEsc) {\n            $document[0].removeEventListener('keydown', modal.closeOnEsc);\n            modal.closeOnEsc = null;\n          }\n        });\n    }\n\n    /**\n     * Helper to close a modal\n     */\n    function closeModal(modalInstance, result, wasDismissed) {\n\n      //Access modal data object\n      let modal = modalInstance.$$modal;\n\n      //No element present?\n      if (!modal.element) {\n        return $q.when(true);\n      }\n\n      //Call on before close handler if given\n      if (typeof modal.onBeforeClose === 'function') {\n\n        //Get outcome\n        let outcome = modal.onBeforeClose(modalInstance, result, wasDismissed);\n\n        //Handle promise\n        if (outcome && typeof outcome.then === 'function') {\n          return outcome\n            .then(() => confirmCloseModal(modalInstance, result, wasDismissed))\n            .catch(reason => $q.reject(reason || REASON_CLOSE_PREVENTED));\n        }\n\n        //Handle other reject reasons\n        if (typeof outcome !== 'undefined' && outcome !== true) {\n          return $q.reject(outcome || REASON_CLOSE_PREVENTED);\n        }\n      }\n\n      //Confirm\n      return confirmCloseModal(modalInstance, result, wasDismissed);\n    }\n\n    /**\n     * Class definition\n     */\n    let Modal = {\n\n      /**\n       * Open a new modal\n       */\n      open(name, options, closeOthers) {\n\n        //No name given?\n        if (typeof name !== 'string') {\n          options = name || {};\n          name = '';\n        }\n\n        //Name given? Merge with predefined configs\n        if (name && typeof configs[name] !== 'undefined') {\n          options = angular.extend({}, configs[name], options || {});\n        }\n        else if (name) {\n          throw new Error('String given as options, but config with name ' +\n            name + ' was not predefined');\n        }\n\n        //Check if already open\n        if (name && options.once && $modalStack.isOpen(name)) {\n          return null;\n        }\n\n        //Validate options\n        options = angular.extend({}, defaults, options || {});\n        options.resolve = options.resolve || {};\n        options.appendTo = options.appendTo || bodyElement;\n\n        //Must have either template or template url specified\n        if (!options.template && !options.templateUrl) {\n          throw new Error('One of template or templateUrl options is required');\n        }\n\n        if (!options.appendTo.length) {\n          throw new Error('Element to append modal to not found in the DOM');\n        }\n\n        //Prepare modal data object\n        const modal = Object.assign({\n          openedDeferred: $q.defer(),\n          closedDeferred: $q.defer(),\n          resultDeferred: $q.defer(),\n          parent: options.appendTo,\n          showOverlay: options.overlay,\n          element: angular.element('<div></div>'),\n        }, options);\n\n        //Create modal instance interface\n        const modalInstance = {\n          $$modal: modal,\n          name,\n          opened: modal.openedDeferred.promise,\n          closed: modal.closedDeferred.promise,\n          result: modal.resultDeferred.promise,\n          resolve(result) {\n            return closeModal(modalInstance, result);\n          },\n          close(reason) {\n            return closeModal(modalInstance, reason, true);\n          },\n        };\n\n        //Close on escape?\n        if (options.closeOnEsc) {\n          modal.closeOnEsc = function(event) {\n            const key = event.keyCode || event.which;\n            if (key === 27 && (!name || $modalStack.isLast(name))) {\n              $rootScope.$apply(() => {\n                closeModal(modalInstance, REASON_CANCEL, true);\n              });\n            }\n          };\n          $document[0].addEventListener('keydown', modal.closeOnEsc);\n        }\n\n        //Enter broadcast\n        modal.broadcastEnter = function(event) {\n          const key = event.keyCode || event.which;\n          const isTextarea = (event.target.tagName === 'TEXTAREA');\n          if (key === 13 && !event.defaultPrevented && !isTextarea) {\n            $rootScope.$broadcast('$modalEnterKey', modalInstance, event);\n          }\n        };\n        $document[0].addEventListener('keydown', modal.broadcastEnter);\n\n        //Wait for template and resolves to resolve\n        $q.all([\n          getTemplatePromise(options.template, options.templateUrl),\n          ...getResolvePromises(options.resolve),\n        ])\n          .then(resolves => {\n\n            //Get template content\n            modal.content = resolves.shift();\n\n            //Determine modal scope and link close/resolve handlers\n            modal.scope = (options.scope || $rootScope).$new();\n            modal.scope.$close = modalInstance.close;\n            modal.scope.$resolve = modalInstance.resolve;\n\n            //Controller given?\n            if (options.controller) {\n\n              //Initialize controller vars\n              const locals = {};\n\n              //Provide scope and modal instance\n              locals.$scope = modal.scope;\n              locals.$modalInstance = modalInstance;\n              locals.$element = modal.element;\n\n              //Provide other passed locals\n              if (options.locals && typeof options.locals === 'object') {\n                angular.forEach(options.locals, function(value, key) {\n                  locals[key] = value;\n                });\n              }\n\n              //Provide resolved values\n              //eslint-disable-next-line no-unused-vars\n              angular.forEach(options.resolve, function(value, key) {\n                locals[key] = resolves.shift();\n              });\n\n              //Create controller instance\n              modal.controller = $controller(options.controller, locals);\n              if (options.controllerAs) {\n                modal.scope[options.controllerAs] = modal.controller;\n              }\n\n              //Attach locals to controller\n              angular.forEach(locals, (value, key) => {\n                modal.controller[key] = value;\n              });\n            }\n\n            //Close others?\n            if (closeOthers) {\n              Modal.closeAll();\n            }\n\n            //Open modal now\n            openModal(modalInstance);\n          })\n          .catch(reason => {\n            modal.openedDeferred.reject(reason);\n            modal.resultDeferred.reject(reason);\n          });\n\n        //Return modal instance\n        return modalInstance;\n      },\n\n      /**\n       * Close all modals\n       */\n      closeAll() {\n        const stack = $modalStack.get();\n        angular.forEach(stack, function(modalInstance) {\n          closeModal(modalInstance, REASON_CANCEL, true);\n        });\n      },\n\n      /**\n       * Check if a specific modal is open\n       */\n      isOpen(name) {\n        return $modalStack.isOpen(name);\n      },\n    };\n\n    //Return the service\n    return Modal;\n  };\n});\n\n})(window, window.angular);\n"]}