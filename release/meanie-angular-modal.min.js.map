{"version":3,"sources":["meanie-angular-modal.min.js","append-animated.service.js","modal-overlay.service.js","modal-stack.service.js","modal.service.js"],"names":["_toConsumableArray","arr","Array","isArray","i","arr2","length","from","module","angular","undefined","factory","child","parent","children","window","$animate","enter","$document","$appendAnimated","overlayElement","bodyElement","find","eq","show","overlayClass","class","element","attr","hide","leave","setIndex","baseIndex","numModals","zIndex","stack","get","isEmpty","numOpen","isOpen","name","isLast","last","add","modalInstance","push","remove","index","indexOf","splice","_typeof","Symbol","iterator","obj","constructor","prototype","provider","closeOnEsc","this","controller","controllerAs","resolve","locals","appendTo","overlay","wrapperClass","onBeforeClose","once","configs","setDefaults","defaults","extend","modal","config","_this","forEach","$get","$rootScope","$q","$templateRequest","$injector","$controller","$compile","$modalStack","$modalOverlay","getTemplatePromise","template","templateUrl","when","getResolvePromises","promises","item","isFunction","invoke","openModal","html","content","scope","closeOnClick","closeModal","on","event","target","currentTarget","preventDefault","stopPropagation","$apply","focussable","document","activeElement","offset","focusElement","lockTabbing","querySelectorAll","tabbableSelector","call","isVisible","key","keyCode","which","addEventListener","$onInit","then","catch","$postLink","openedDeferred","reject","reason","confirmCloseModal","result","wasDismissed","$$modal","resultDeferred","$destroy","$onDestroy","removeEventListener","outcome","Modal","open","options","closeOthers","Error","defer","showOverlay","dismiss","opened","promise","close","isTextarea","tagName","broadcastEnter","defaultPrevented","all","shift","$new","resolves","$close","$scope","value","$modalInstance","closeAll"],"mappings":"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","file":"meanie-angular-modal.min.js","sourcesContent":["/**\n * meanie-angular-modal * https://github.com/meanie/angular-modal\n *\n * Copyright (c) 2017 Adam Reis <adam@reis.nz>\n * License: MIT\n */\n(function (window, angular, undefined) {\n  'use strict';\n  /**\n   * Module definition and dependencies\n   */\n\n  angular.module('AppendAnimated.Service', [])\n\n  /**\n   * Append animated helper\n   */\n  .factory('$appendAnimated', ['$animate', function ($animate) {\n    return function (child, parent) {\n      var children = parent.children();\n      if (children.length > 0) {\n        return $animate.enter(child, parent, children[children.length - 1]);\n      }\n      return $animate.enter(child, parent);\n    };\n  }]);\n})(window, window.angular);\n(function (window, angular, undefined) {\n  'use strict';\n\n  /**\n   * Module definition and dependencies\n   */\n\n  angular.module('ModalOverlay.Service', ['AppendAnimated.Service'])\n\n  /**\n   * Modal overlay service\n   */\n  .factory('$modalOverlay', ['$animate', '$document', '$appendAnimated', function ($animate, $document, $appendAnimated) {\n\n    //Global overlay element\n    var overlayElement = void 0;\n    var bodyElement = $document.find('body').eq(0);\n\n    /**\n     * Modal overlay service\n     */\n    return {\n\n      /**\n       * Show overlay element\n       */\n      show: function show(overlayClass) {\n\n        //Already visible?\n        if (overlayElement) {\n          return;\n        }\n\n        //Create element\n        overlayElement = angular.element('<div></div>').attr({\n          class: overlayClass\n        });\n\n        //Animate in\n        return $appendAnimated(overlayElement, bodyElement);\n      },\n\n\n      /**\n       * Hide overlay element\n       */\n      hide: function hide() {\n        if (overlayElement) {\n          $animate.leave(overlayElement);\n          overlayElement = null;\n        }\n      },\n\n\n      /**\n       * Set the proper z-index\n       */\n      setIndex: function setIndex(baseIndex, numModals) {\n        if (overlayElement) {\n          var zIndex = baseIndex + 2 * (numModals - 1);\n          overlayElement[0].style.zIndex = zIndex;\n        }\n      }\n    };\n  }]);\n})(window, window.angular);\n(function (window, angular, undefined) {\n  'use strict';\n\n  /**\n   * Module definition and dependencies\n   */\n\n  angular.module('ModalStack.Service', [])\n\n  /**\n   * Modal stack service\n   */\n  .factory('$modalStack', function () {\n\n    //Stack of modals\n    var stack = [];\n\n    //Modal stack interface\n    return {\n\n      /**\n       * Get modal instances stack\n       */\n      get: function get() {\n        return stack;\n      },\n\n\n      /**\n       * Check if there are open instances\n       */\n      isEmpty: function isEmpty() {\n        return stack.length === 0;\n      },\n\n\n      /**\n       * Get number of modals that are open\n       */\n      numOpen: function numOpen() {\n        return stack.length;\n      },\n\n\n      /**\n       * Check if a specific modal is open\n       */\n      isOpen: function isOpen(name) {\n\n        //Can't distinguish unnamed modals\n        if (!name) {\n          return false;\n        }\n\n        //Check if open\n        for (var i = 0; i < stack.length; i++) {\n          if (stack[i].name === name) {\n            return true;\n          }\n        }\n\n        //Not open\n        return false;\n      },\n\n\n      /**\n       * Check if a specific modal is last\n       */\n      isLast: function isLast(name) {\n\n        //Can't distinguish unnamed modals or work with an empty stack\n        if (!name || stack.length === 0) {\n          return false;\n        }\n\n        //Get last modal and compare name\n        var last = stack[stack.length - 1];\n        return last.name === name;\n      },\n\n\n      /**\n       * Add modal instance to stack\n       */\n      add: function add(modalInstance) {\n        stack.push(modalInstance);\n      },\n\n\n      /**\n       * Remove modal instance from stack\n       */\n      remove: function remove(modalInstance) {\n        var index = stack.indexOf(modalInstance);\n        if (index > -1) {\n          stack.splice(index, 1);\n        }\n      }\n    };\n  });\n})(window, window.angular);\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n(function (window, angular, undefined) {\n  'use strict';\n\n  /**\n   * Module definition and dependencies\n   */\n\n  angular.module('Modal.Service', ['ModalStack.Service', 'ModalOverlay.Service', 'AppendAnimated.Service'])\n\n  /**\n   * Modal service\n   */\n  .provider('$modal', function $modalProvider() {\n\n    /**\n     * Defaults\n     */\n    this.defaults = {\n      closeOnEsc: true,\n      closeOnClick: true,\n      template: null,\n      templateUrl: null,\n      scope: null,\n      controller: null,\n      controllerAs: '$ctrl',\n      resolve: {},\n      locals: null,\n      appendTo: null,\n      overlay: true,\n      wrapperClass: 'modal-wrapper ModalWrapper',\n      overlayClass: 'modal-overlay ModalOverlay',\n      onBeforeClose: null,\n      once: false\n    };\n\n    /**\n     * Store of predefined modal configs\n     */\n    this.configs = {};\n\n    /**\n     * Set defaults\n     */\n    this.setDefaults = function (defaults) {\n      this.defaults = angular.extend(this.defaults, defaults || {});\n      return this;\n    };\n\n    /**\n     * Predefine a modal config\n     */\n    this.modal = function (name, config) {\n      var _this = this;\n\n      //Object hash given?\n      if (name && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n        angular.forEach(name, function (config, name) {\n          _this.modal(name, config);\n        }, this);\n        return;\n      }\n\n      //Set config and return self\n      this.configs[name] = angular.extend({}, this.defaults, config || {});\n      return this;\n    };\n\n    /**\n     * Service getter\n     */\n    this.$get = ['$rootScope', '$q', '$templateRequest', '$injector', '$controller', '$compile', '$document', '$animate', '$modalStack', '$modalOverlay', '$appendAnimated', function ($rootScope, $q, $templateRequest, $injector, $controller, $compile, $document, $animate, $modalStack, $modalOverlay, $appendAnimated) {\n\n      //Get defaults and configs\n      var baseIndex = 10000;\n      var defaults = this.defaults;\n      var configs = this.configs;\n\n      //Get body element\n      var bodyElement = $document.find('body').eq(0);\n\n      /**\n       * Helper to get template promise\n       */\n      function getTemplatePromise(template, templateUrl) {\n        if (template) {\n          return $q.when(template);\n        }\n        return $templateRequest(templateUrl, true);\n      }\n\n      /**\n       * Helper to get resolve promises\n       */\n      function getResolvePromises(resolves) {\n        var promises = [];\n        angular.forEach(resolves, function (item) {\n          if (angular.isFunction(item) || angular.isArray(item)) {\n            promises.push($q.when($injector.invoke(item)));\n          } else if (angular.isString(item)) {\n            promises.push($q.when($injector.get(item)));\n          } else {\n            promises.push($q.when(item));\n          }\n        });\n        return promises;\n      }\n\n      /**\n       * Helper to open a modal\n       */\n      function openModal(modalInstance) {\n\n        //Access modal data object\n        var modal = modalInstance.$$modal;\n        var numModals = $modalStack.numOpen() + 1;\n\n        //Create then compile modal element\n        modal.element = angular.element('<div></div>').attr({ class: modal.wrapperClass }).html(modal.content);\n        modal.element = $compile(modal.element)(modal.scope);\n        modal.element[0].style.zIndex = baseIndex + 2 * numModals - 1;\n\n        //Close on click handler\n        //NOTE: This is applied on the base modal element, e.g. invisible\n        //background, not the overlay. This is because clicking on the overlay\n        //would then close all modals, which is probably not what you'd want.\n        if (modal.closeOnClick) {\n          modal.element.on('click', function (event) {\n            if (event.target === event.currentTarget) {\n              event.preventDefault();\n              event.stopPropagation();\n              $rootScope.$apply(function () {\n                closeModal(modalInstance, 'cancel', true);\n              });\n            }\n          });\n        }\n\n        //Tabbing control\n        (function tabbingControl() {\n          var tabbableSelector = 'a[href], ' + 'area[href], ' + 'input:not([disabled]):not([tabindex=\\'-1\\']), ' + 'button:not([disabled]):not([tabindex=\\'-1\\']),' + 'select:not([disabled]):not([tabindex=\\'-1\\']), ' + 'textarea:not([disabled]):not([tabindex=\\'-1\\']), ' + 'iframe, object, embed, ' + '*[tabindex]:not([tabindex=\\'-1\\']), ' + '*[contenteditable=true]';\n\n          function isVisible(element) {\n            return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);\n          }\n\n          function focusElement(offset) {\n            var possibleFocussable = modal.element[0].querySelectorAll(tabbableSelector);\n            var focussable = Array.prototype.filter.call(modal.element[0].querySelectorAll(tabbableSelector), isVisible);\n            var index = focussable.indexOf(document.activeElement) + offset;\n            var target = index < 0 ? focussable.length - 1 : focussable.length > index ? index : 0;\n            focussable[target].focus();\n          }\n\n          modal.lockTabbing = function (event) {\n            var key = event.keyCode || event.which;\n            if (key === 9) {\n              focusElement(event.shiftKey ? -1 : 1);\n              event.preventDefault();\n              return false;\n            }\n          };\n\n          $document[0].addEventListener('keydown', modal.lockTabbing);\n        })();\n\n        //Add to stack and show overlay\n        $modalStack.add(modalInstance);\n        if (modal.showOverlay) {\n          $modalOverlay.show(modal.overlayClass);\n          $modalOverlay.setIndex(baseIndex, numModals);\n        }\n\n        //Call controller on init now\n        if (modal.controller && modal.controller.$onInit) {\n          modal.controller.$onInit.call(modal.controller);\n        }\n\n        //Append animated and resolve opened deferred\n        return $appendAnimated(modal.element, modal.parent).then(function () {\n\n          //Call controller $postLink\n          if (modal.controller && modal.controller.$postLink) {\n            modal.controller.$postLink.call(modal.controller);\n          }\n\n          //Resolve open\n          modal.openedDeferred.resolve(true);\n        }).catch(function (reason) {\n          return modal.openedDeferred.reject(reason);\n        });\n      }\n\n      /**\n       * Helper to actually close modal after confirmed\n       */\n      function confirmCloseModal(modalInstance, result, wasDismissed) {\n\n        //Access modal data object\n        var modal = modalInstance.$$modal;\n        var numModals = $modalStack.numOpen() - 1;\n\n        //No element present?\n        if (!modal.element) {\n          return $q.when(true);\n        }\n\n        //Did we get a result\n        if (wasDismissed) {\n          modal.resultDeferred.reject(result);\n        } else {\n          modal.resultDeferred.resolve(result);\n        }\n\n        //Remove from stack\n        $modalStack.remove(modalInstance);\n        if ($modalStack.isEmpty()) {\n          $modalOverlay.hide();\n        } else {\n          $modalOverlay.setIndex(baseIndex, numModals);\n        }\n\n        //Animate out\n        return $animate.leave(modal.element).then(function () {\n\n          //Call controller on destroy now\n          if (modal.controller && modal.controller.$onDestroy) {\n            modal.controller.$onDestroy.call(modal.controller);\n          }\n\n          //Clean up scope\n          if (modal.scope) {\n            modal.scope.$destroy();\n            modal.scope = null;\n          }\n\n          //Remove element reference\n          modal.element = null;\n\n          //Remove event listeners\n          $document[0].removeEventListener('keydown', modal.broadcastEnter);\n          if (modal.closeOnEsc) {\n            $document[0].removeEventListener('keydown', modal.closeOnEsc);\n            modal.closeOnEsc = null;\n          }\n          if (modal.lockTabbing) {\n            $document[0].removeEventListener('keydown', modal.lockTabbing);\n            modal.lockTabbing = null;\n          }\n        });\n      }\n\n      /**\n       * Helper to close a modal\n       */\n      function closeModal(modalInstance, result, wasDismissed) {\n\n        //Access modal data object\n        var modal = modalInstance.$$modal;\n\n        //No element present?\n        if (!modal.element) {\n          return $q.when(true);\n        }\n\n        //Call on before close handler if given\n        if (typeof modal.onBeforeClose === 'function') {\n\n          //Get outcome\n          var outcome = modal.onBeforeClose(modalInstance, result, wasDismissed);\n\n          //Handle promise\n          if (outcome && typeof outcome.then === 'function') {\n            return outcome.then(function () {\n              return confirmCloseModal(modalInstance, result, wasDismissed);\n            }).catch(function (reason) {\n              return $q.reject(reason || 'Close prevented');\n            });\n          }\n\n          //Handle other reject reasons\n          if (typeof outcome !== 'undefined' && outcome !== true) {\n            return $q.reject(outcome || 'Close prevented');\n          }\n        }\n\n        //Confirm\n        return confirmCloseModal(modalInstance, result, wasDismissed);\n      }\n\n      /**\n       * Class definition\n       */\n      var Modal = {\n\n        /**\n         * Open a new modal\n         */\n        open: function open(name, options, closeOthers) {\n\n          //No name given?\n          if (typeof name !== 'string') {\n            options = name || {};\n            name = '';\n          }\n\n          //Name given? Merge with predefined configs\n          if (name && typeof configs[name] !== 'undefined') {\n            options = angular.extend({}, configs[name], options || {});\n          } else if (name) {\n            throw new Error('String given as options, but config with name ' + name + ' was not predefined');\n          }\n\n          //Check if already open\n          if (name && options.once && $modalStack.isOpen(name)) {\n            return null;\n          }\n\n          //Validate options\n          options = angular.extend({}, defaults, options || {});\n          options.resolve = options.resolve || {};\n          options.appendTo = options.appendTo || bodyElement;\n\n          //Must have either template or template url specified\n          if (!options.template && !options.templateUrl) {\n            throw new Error('One of template or templateUrl options is required');\n          }\n\n          if (!options.appendTo.length) {\n            throw new Error('Element to append modal to not found in the DOM');\n          }\n\n          //Prepare modal data object\n          var modal = {\n            openedDeferred: $q.defer(),\n            resultDeferred: $q.defer(),\n            parent: options.appendTo,\n            wrapperClass: options.wrapperClass,\n            overlayClass: options.overlayClass,\n            showOverlay: options.overlay,\n            closeOnClick: options.closeOnClick,\n            onBeforeClose: options.onBeforeClose\n          };\n\n          //Create modal instance interface\n          var modalInstance = {\n            $$modal: modal,\n            name: name,\n            opened: modal.openedDeferred.promise,\n            result: modal.resultDeferred.promise,\n            close: function close(result) {\n              return closeModal(modalInstance, result);\n            },\n            dismiss: function dismiss(reason) {\n              return closeModal(modalInstance, reason, true);\n            }\n          };\n\n          //Close on escape?\n          if (options.closeOnEsc) {\n            modal.closeOnEsc = function (event) {\n              var key = event.keyCode || event.which;\n              if (key === 27 && (!name || $modalStack.isLast(name))) {\n                $rootScope.$apply(function () {\n                  closeModal(modalInstance, 'cancel', true);\n                });\n              }\n            };\n            $document[0].addEventListener('keydown', modal.closeOnEsc);\n          }\n\n          //Enter broadcast\n          modal.broadcastEnter = function (event) {\n            var key = event.keyCode || event.which;\n            var isTextarea = event.target.tagName === 'TEXTAREA';\n            if (key === 13 && !event.defaultPrevented && !isTextarea) {\n              $rootScope.$broadcast('$modalEnterKey', modalInstance, event);\n            }\n          };\n          $document[0].addEventListener('keydown', modal.broadcastEnter);\n\n          //Wait for template and resolves to resolve\n          $q.all([getTemplatePromise(options.template, options.templateUrl)].concat(_toConsumableArray(getResolvePromises(options.resolve)))).then(function (resolves) {\n\n            //Get template content\n            modal.content = resolves.shift();\n\n            //Determine modal scope and link close/dismiss handlers\n            modal.scope = (options.scope || $rootScope).$new();\n            modal.scope.$close = modalInstance.close;\n            modal.scope.$dismiss = modalInstance.dismiss;\n\n            //Controller given?\n            if (options.controller) {\n\n              //Initialize controller vars\n              var locals = {};\n\n              //Provide scope and modal instance\n              locals.$scope = modal.scope;\n              locals.$modalInstance = modalInstance;\n\n              //Provide other passed locals\n              if (options.locals && _typeof(options.locals) === 'object') {\n                angular.forEach(options.locals, function (value, key) {\n                  locals[key] = value;\n                });\n              }\n\n              //Provide resolved values\n              angular.forEach(options.resolve, function (value, key) {\n                locals[key] = resolves.shift();\n              });\n\n              //Create controller instance\n              modal.controller = $controller(options.controller, locals);\n              if (options.controllerAs) {\n                modal.scope[options.controllerAs] = modal.controller;\n              }\n\n              //Attach locals to controller\n              angular.forEach(options.locals, function (value, key) {\n                modal.controller[key] = value;\n              });\n            }\n\n            //Close others?\n            if (closeOthers) {\n              Modal.closeAll();\n            }\n\n            //Open modal now\n            openModal(modalInstance);\n          }).catch(function (reason) {\n            modal.openedDeferred.reject(reason);\n            modal.resultDeferred.reject(reason);\n          });\n\n          //Return modal instance\n          return modalInstance;\n        },\n\n\n        /**\n         * Close all modals\n         */\n        closeAll: function closeAll() {\n          var stack = $modalStack.get();\n          angular.forEach(stack, function (modalInstance) {\n            closeModal(modalInstance, 'cancel', true);\n          });\n        },\n\n\n        /**\n         * Check if a specific modal is open\n         */\n        isOpen: function isOpen(name) {\n          return $modalStack.isOpen(name);\n        }\n      };\n\n      //Return the service\n      return Modal;\n    }];\n  });\n})(window, window.angular);","(function(window, angular, undefined) {'use strict';\n/**\n * Module definition and dependencies\n */\nangular.module('AppendAnimated.Service', [])\n\n/**\n * Append animated helper\n */\n.factory('$appendAnimated', $animate => {\n  return function(child, parent) {\n    let children = parent.children();\n    if (children.length > 0) {\n      return $animate.enter(child, parent, children[children.length - 1]);\n    }\n    return $animate.enter(child, parent);\n  };\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ModalOverlay.Service', [\n  'AppendAnimated.Service',\n])\n\n/**\n * Modal overlay service\n */\n.factory('$modalOverlay', ($animate, $document, $appendAnimated) => {\n\n  //Global overlay element\n  let overlayElement;\n  let bodyElement = $document.find('body').eq(0);\n\n  /**\n   * Modal overlay service\n   */\n  return {\n\n    /**\n     * Show overlay element\n     */\n    show(overlayClass) {\n\n      //Already visible?\n      if (overlayElement) {\n        return;\n      }\n\n      //Create element\n      overlayElement = angular.element('<div></div>').attr({\n        class: overlayClass,\n      });\n\n      //Animate in\n      return $appendAnimated(overlayElement, bodyElement);\n    },\n\n    /**\n     * Hide overlay element\n     */\n    hide() {\n      if (overlayElement) {\n        $animate.leave(overlayElement);\n        overlayElement = null;\n      }\n    },\n\n    /**\n     * Set the proper z-index\n     */\n    setIndex(baseIndex, numModals) {\n      if (overlayElement) {\n        const zIndex = baseIndex + 2 * (numModals - 1);\n        overlayElement[0].style.zIndex = zIndex;\n      }\n    },\n  };\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('ModalStack.Service', [])\n\n/**\n * Modal stack service\n */\n.factory('$modalStack', () => {\n\n  //Stack of modals\n  const stack = [];\n\n  //Modal stack interface\n  return {\n\n    /**\n     * Get modal instances stack\n     */\n    get() {\n      return stack;\n    },\n\n    /**\n     * Check if there are open instances\n     */\n    isEmpty() {\n      return (stack.length === 0);\n    },\n\n    /**\n     * Get number of modals that are open\n     */\n    numOpen() {\n      return stack.length;\n    },\n\n    /**\n     * Check if a specific modal is open\n     */\n    isOpen(name) {\n\n      //Can't distinguish unnamed modals\n      if (!name) {\n        return false;\n      }\n\n      //Check if open\n      for (let i = 0; i < stack.length; i++) {\n        if (stack[i].name === name) {\n          return true;\n        }\n      }\n\n      //Not open\n      return false;\n    },\n\n    /**\n     * Check if a specific modal is last\n     */\n    isLast(name) {\n\n      //Can't distinguish unnamed modals or work with an empty stack\n      if (!name || stack.length === 0) {\n        return false;\n      }\n\n      //Get last modal and compare name\n      const last = stack[stack.length - 1];\n      return (last.name === name);\n    },\n\n    /**\n     * Add modal instance to stack\n     */\n    add(modalInstance) {\n      stack.push(modalInstance);\n    },\n\n    /**\n     * Remove modal instance from stack\n     */\n    remove(modalInstance) {\n      const index = stack.indexOf(modalInstance);\n      if (index > -1) {\n        stack.splice(index, 1);\n      }\n    },\n  };\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('Modal.Service', [\n  'ModalStack.Service',\n  'ModalOverlay.Service',\n  'AppendAnimated.Service',\n])\n\n/**\n * Modal service\n */\n.provider('$modal', function $modalProvider() {\n\n  /**\n   * Defaults\n   */\n  this.defaults = {\n    closeOnEsc: true,\n    closeOnClick: true,\n    template: null,\n    templateUrl: null,\n    scope: null,\n    controller: null,\n    controllerAs: '$ctrl',\n    resolve: {},\n    locals: null,\n    appendTo: null,\n    overlay: true,\n    wrapperClass: 'modal-wrapper ModalWrapper',\n    overlayClass: 'modal-overlay ModalOverlay',\n    onBeforeClose: null,\n    once: false,\n  };\n\n  /**\n   * Store of predefined modal configs\n   */\n  this.configs = {};\n\n  /**\n   * Set defaults\n   */\n  this.setDefaults = function(defaults) {\n    this.defaults = angular.extend(this.defaults, defaults || {});\n    return this;\n  };\n\n  /**\n   * Predefine a modal config\n   */\n  this.modal = function(name, config) {\n\n    //Object hash given?\n    if (name && typeof name === 'object') {\n      angular.forEach(name, (config, name) => {\n        this.modal(name, config);\n      }, this);\n      return;\n    }\n\n    //Set config and return self\n    this.configs[name] = angular.extend({}, this.defaults, config || {});\n    return this;\n  };\n\n  /**\n   * Service getter\n   */\n  this.$get = function(\n    $rootScope, $q, $templateRequest, $injector, $controller,\n    $compile, $document, $animate, $modalStack, $modalOverlay,\n    $appendAnimated\n  ) {\n\n    //Get defaults and configs\n    const baseIndex = 10000;\n    const defaults = this.defaults;\n    const configs = this.configs;\n\n    //Get body element\n    const bodyElement = $document.find('body').eq(0);\n\n    /**\n     * Helper to get template promise\n     */\n    function getTemplatePromise(template, templateUrl) {\n      if (template) {\n        return $q.when(template);\n      }\n      return $templateRequest(templateUrl, true);\n    }\n\n    /**\n     * Helper to get resolve promises\n     */\n    function getResolvePromises(resolves) {\n      let promises = [];\n      angular.forEach(resolves, item => {\n        if (angular.isFunction(item) || angular.isArray(item)) {\n          promises.push($q.when($injector.invoke(item)));\n        }\n        else if (angular.isString(item)) {\n          promises.push($q.when($injector.get(item)));\n        }\n        else {\n          promises.push($q.when(item));\n        }\n      });\n      return promises;\n    }\n\n    /**\n     * Helper to open a modal\n     */\n    function openModal(modalInstance) {\n\n      //Access modal data object\n      const modal = modalInstance.$$modal;\n      const numModals = $modalStack.numOpen() + 1;\n\n      //Create then compile modal element\n      modal.element = angular\n        .element('<div></div>')\n        .attr({class: modal.wrapperClass})\n        .html(modal.content);\n      modal.element = $compile(modal.element)(modal.scope);\n      modal.element[0].style.zIndex = baseIndex + (2 * numModals) - 1;\n\n      //Close on click handler\n      //NOTE: This is applied on the base modal element, e.g. invisible\n      //background, not the overlay. This is because clicking on the overlay\n      //would then close all modals, which is probably not what you'd want.\n      if (modal.closeOnClick) {\n        modal.element.on('click', event => {\n          if (event.target === event.currentTarget) {\n            event.preventDefault();\n            event.stopPropagation();\n            $rootScope.$apply(() => {\n              closeModal(modalInstance, 'cancel', true);\n            });\n          }\n        });\n      }\n\n      //Tabbing control\n      (function tabbingControl() {\n        const tabbableSelector =\n              'a[href], ' +\n              'area[href], ' +\n              'input:not([disabled]):not([tabindex=\\'-1\\']), ' +\n              'button:not([disabled]):not([tabindex=\\'-1\\']),' +\n              'select:not([disabled]):not([tabindex=\\'-1\\']), ' +\n              'textarea:not([disabled]):not([tabindex=\\'-1\\']), ' +\n              'iframe, object, embed, ' +\n              '*[tabindex]:not([tabindex=\\'-1\\']), ' +\n              '*[contenteditable=true]';\n\n        function isVisible(element) {\n          return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);\n        }\n\n        function focusElement(offset) {\n          let possibleFocussable = modal.element[0].querySelectorAll(tabbableSelector);\n          let focussable = Array.prototype.filter.call(modal.element[0].querySelectorAll(tabbableSelector), isVisible);\n          let index = focussable.indexOf(document.activeElement) + offset;\n          let target = index < 0 ? focussable.length - 1 : focussable.length > index ? index : 0;\n          focussable[target].focus();\n        }\n\n        modal.lockTabbing = function(event) {\n          let key = event.keyCode || event.which;\n          if (key === 9) {\n            focusElement(event.shiftKey ? -1 : 1);\n            event.preventDefault();\n            return false;\n          }\n        };\n\n        $document[0].addEventListener('keydown', modal.lockTabbing);\n      })();\n\n      //Add to stack and show overlay\n      $modalStack.add(modalInstance);\n      if (modal.showOverlay) {\n        $modalOverlay.show(modal.overlayClass);\n        $modalOverlay.setIndex(baseIndex, numModals);\n      }\n\n      //Call controller on init now\n      if (modal.controller && modal.controller.$onInit) {\n        modal.controller.$onInit.call(modal.controller);\n      }\n\n      //Append animated and resolve opened deferred\n      return $appendAnimated(modal.element, modal.parent)\n        .then(() => {\n\n          //Call controller $postLink\n          if (modal.controller && modal.controller.$postLink) {\n            modal.controller.$postLink.call(modal.controller);\n          }\n\n          //Resolve open\n          modal.openedDeferred.resolve(true);\n        })\n        .catch(reason => modal.openedDeferred.reject(reason));\n    }\n\n    /**\n     * Helper to actually close modal after confirmed\n     */\n    function confirmCloseModal(modalInstance, result, wasDismissed) {\n\n      //Access modal data object\n      let modal = modalInstance.$$modal;\n      let numModals = $modalStack.numOpen() - 1;\n\n      //No element present?\n      if (!modal.element) {\n        return $q.when(true);\n      }\n\n      //Did we get a result\n      if (wasDismissed) {\n        modal.resultDeferred.reject(result);\n      }\n      else {\n        modal.resultDeferred.resolve(result);\n      }\n\n      //Remove from stack\n      $modalStack.remove(modalInstance);\n      if ($modalStack.isEmpty()) {\n        $modalOverlay.hide();\n      }\n      else {\n        $modalOverlay.setIndex(baseIndex, numModals);\n      }\n\n      //Animate out\n      return $animate.leave(modal.element)\n        .then(() => {\n\n          //Call controller on destroy now\n          if (modal.controller && modal.controller.$onDestroy) {\n            modal.controller.$onDestroy.call(modal.controller);\n          }\n\n          //Clean up scope\n          if (modal.scope) {\n            modal.scope.$destroy();\n            modal.scope = null;\n          }\n\n          //Remove element reference\n          modal.element = null;\n\n          //Remove event listeners\n          $document[0].removeEventListener('keydown', modal.broadcastEnter);\n          if (modal.closeOnEsc) {\n            $document[0].removeEventListener('keydown', modal.closeOnEsc);\n            modal.closeOnEsc = null;\n          }\n          if (modal.lockTabbing) {\n            $document[0].removeEventListener('keydown', modal.lockTabbing);\n            modal.lockTabbing = null;\n          }\n        });\n    }\n\n    /**\n     * Helper to close a modal\n     */\n    function closeModal(modalInstance, result, wasDismissed) {\n\n      //Access modal data object\n      let modal = modalInstance.$$modal;\n\n      //No element present?\n      if (!modal.element) {\n        return $q.when(true);\n      }\n\n      //Call on before close handler if given\n      if (typeof modal.onBeforeClose === 'function') {\n\n        //Get outcome\n        let outcome = modal.onBeforeClose(modalInstance, result, wasDismissed);\n\n        //Handle promise\n        if (outcome && typeof outcome.then === 'function') {\n          return outcome\n            .then(() => confirmCloseModal(modalInstance, result, wasDismissed))\n            .catch(reason => $q.reject(reason || 'Close prevented'));\n        }\n\n        //Handle other reject reasons\n        if (typeof outcome !== 'undefined' && outcome !== true) {\n          return $q.reject(outcome || 'Close prevented');\n        }\n      }\n\n      //Confirm\n      return confirmCloseModal(modalInstance, result, wasDismissed);\n    }\n\n    /**\n     * Class definition\n     */\n    let Modal = {\n\n      /**\n       * Open a new modal\n       */\n      open(name, options, closeOthers) {\n\n        //No name given?\n        if (typeof name !== 'string') {\n          options = name || {};\n          name = '';\n        }\n\n        //Name given? Merge with predefined configs\n        if (name && typeof configs[name] !== 'undefined') {\n          options = angular.extend({}, configs[name], options || {});\n        }\n        else if (name) {\n          throw new Error('String given as options, but config with name ' +\n            name + ' was not predefined');\n        }\n\n        //Check if already open\n        if (name && options.once && $modalStack.isOpen(name)) {\n          return null;\n        }\n\n        //Validate options\n        options = angular.extend({}, defaults, options || {});\n        options.resolve = options.resolve || {};\n        options.appendTo = options.appendTo || bodyElement;\n\n        //Must have either template or template url specified\n        if (!options.template && !options.templateUrl) {\n          throw new Error('One of template or templateUrl options is required');\n        }\n\n        if (!options.appendTo.length) {\n          throw new Error('Element to append modal to not found in the DOM');\n        }\n\n        //Prepare modal data object\n        let modal = {\n          openedDeferred: $q.defer(),\n          resultDeferred: $q.defer(),\n          parent: options.appendTo,\n          wrapperClass: options.wrapperClass,\n          overlayClass: options.overlayClass,\n          showOverlay: options.overlay,\n          closeOnClick: options.closeOnClick,\n          onBeforeClose: options.onBeforeClose,\n        };\n\n        //Create modal instance interface\n        let modalInstance = {\n          $$modal: modal,\n          name,\n          opened: modal.openedDeferred.promise,\n          result: modal.resultDeferred.promise,\n          close(result) {\n            return closeModal(modalInstance, result);\n          },\n          dismiss(reason) {\n            return closeModal(modalInstance, reason, true);\n          },\n        };\n\n        //Close on escape?\n        if (options.closeOnEsc) {\n          modal.closeOnEsc = function(event) {\n            let key = event.keyCode || event.which;\n            if (key === 27 && (!name || $modalStack.isLast(name))) {\n              $rootScope.$apply(() => {\n                closeModal(modalInstance, 'cancel', true);\n              });\n            }\n          };\n          $document[0].addEventListener('keydown', modal.closeOnEsc);\n        }\n\n        //Enter broadcast\n        modal.broadcastEnter = function(event) {\n          let key = event.keyCode || event.which;\n          let isTextarea = (event.target.tagName === 'TEXTAREA');\n          if (key === 13 && !event.defaultPrevented && !isTextarea) {\n            $rootScope.$broadcast('$modalEnterKey', modalInstance, event);\n          }\n        };\n        $document[0].addEventListener('keydown', modal.broadcastEnter);\n\n        //Wait for template and resolves to resolve\n        $q.all([\n          getTemplatePromise(options.template, options.templateUrl),\n          ...getResolvePromises(options.resolve),\n        ])\n          .then(resolves => {\n\n            //Get template content\n            modal.content = resolves.shift();\n\n            //Determine modal scope and link close/dismiss handlers\n            modal.scope = (options.scope || $rootScope).$new();\n            modal.scope.$close = modalInstance.close;\n            modal.scope.$dismiss = modalInstance.dismiss;\n\n            //Controller given?\n            if (options.controller) {\n\n              //Initialize controller vars\n              let locals = {};\n\n              //Provide scope and modal instance\n              locals.$scope = modal.scope;\n              locals.$modalInstance = modalInstance;\n\n              //Provide other passed locals\n              if (options.locals && typeof options.locals === 'object') {\n                angular.forEach(options.locals, function(value, key) {\n                  locals[key] = value;\n                });\n              }\n\n              //Provide resolved values\n              angular.forEach(options.resolve, function(value, key) {\n                locals[key] = resolves.shift();\n              });\n\n              //Create controller instance\n              modal.controller = $controller(options.controller, locals);\n              if (options.controllerAs) {\n                modal.scope[options.controllerAs] = modal.controller;\n              }\n\n              //Attach locals to controller\n              angular.forEach(options.locals, (value, key) => {\n                modal.controller[key] = value;\n              });\n            }\n\n            //Close others?\n            if (closeOthers) {\n              Modal.closeAll();\n            }\n\n            //Open modal now\n            openModal(modalInstance);\n          })\n          .catch(reason => {\n            modal.openedDeferred.reject(reason);\n            modal.resultDeferred.reject(reason);\n          });\n\n        //Return modal instance\n        return modalInstance;\n      },\n\n      /**\n       * Close all modals\n       */\n      closeAll() {\n        let stack = $modalStack.get();\n        angular.forEach(stack, function(modalInstance) {\n          closeModal(modalInstance, 'cancel', true);\n        });\n      },\n\n      /**\n       * Check if a specific modal is open\n       */\n      isOpen(name) {\n        return $modalStack.isOpen(name);\n      },\n    };\n\n    //Return the service\n    return Modal;\n  };\n});\n\n})(window, window.angular);\n"]}